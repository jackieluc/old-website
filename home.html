<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Jackie Luc</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
  </head>
  <body>
    <script src="threejs/build/three.js"></script>

    <script src="threejs/renderers/Projector.js"></script>
    <script src="threejs/renderers/CanvasRenderer.js"></script>

    <script>
        var container;

        var camera, scene, renderer;

        var group;

        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;

        var loader = new THREE.FontLoader();
        loader.load( 'threejs/fonts/droid_sans_regular.typeface.json', function ( font ) {

            init( font );
            animate();

        } );

        function init( font ) {

            //create an element to display onto the screen
            container = document.createElement( 'div' );
            document.body.appendChild( container );

            //create the camera and set the camera position
            camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.set( 0, 150, 500 );

            scene = new THREE.Scene();

            //the texts that will be displayed on screen
            var text = "Website Under Construction";
            var name = "{ Jackie Luc }";

            //create geometry for the two texts
            var textGeometry = new THREE.TextGeometry( text, {
                font: font,
                size: 40,
                height: 20,
                curveSegments: 2
            });

            var nameGeometry = new THREE.TextGeometry( name, {
                font: font,
                size: 20,
                height: 10,
                curveSegments: 2
            });

            //calculate middle offset for texts
            textGeometry.computeBoundingBox();
            var textOffset = -0.5 * ( textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x );

            nameGeometry.computeBoundingBox();
            var nameOffset = -0.5 * ( nameGeometry.boundingBox.max.x - nameGeometry.boundingBox.min.x );

            //color the texts
            var textMaterial = new THREE.MultiMaterial( [
                new THREE.MeshBasicMaterial( { color: 0xff6666, overdraw: 0.5 } ),
                new THREE.MeshBasicMaterial( { color: 0xfcb0b3, overdraw: 0.5 } )
            ] );

            var nameMaterial = new THREE.MultiMaterial( [
                new THREE.MeshBasicMaterial( { color: 0x6699cc, overdraw: 0.5 } ),
                new THREE.MeshBasicMaterial( { color: 0xb2cce5, overdraw: 0.5 } )
            ] );

            //create meshes for the texts and position them accordingly
            var textMesh = new THREE.Mesh( textGeometry, textMaterial );
            var nameMesh = new THREE.Mesh( nameGeometry, nameMaterial );

            textMesh.position.x = textOffset;
            textMesh.position.y = 100;
            textMesh.position.z = 0;

            // textMesh.rotation.x = 0;
            // textMesh.rotation.y = Math.PI * 2;

            nameMesh.position.x = nameOffset;
            nameMesh.position.y = 10;
            nameMesh.position.z = 0;

            group = new THREE.Group();
            group.add( textMesh );
            //group.add( nameMesh );

            scene.add( group );
            scene.add( nameMesh );

            //render the scene and add the scene to display to the user
            renderer = new THREE.CanvasRenderer();
            renderer.setClearColor( 0x000000, 0.9 );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            //listener to adjust when window is resized
            window.addEventListener( 'resize', onWindowResize, false );

        }

        function onWindowResize() {

            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {

            requestAnimationFrame( animate );

            render();

        }

        function render() {

            group.rotation.y -= 0.05;
            renderer.render( scene, camera );

        }

        </script>
    </body>
</html>
